<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Expandable CTF Knowledge Graph</title>
<style>
  body { background:#1e1e1e; color:white; font-family:sans-serif; overflow:hidden; }
  .link { stroke:#888; stroke-opacity:0.6; marker-end:url(#arrow); }
  .edge-label { fill:#ccc; font-size:10px; pointer-events:none; text-anchor:middle; }
  .node text { fill:white; font-size:12px; pointer-events:none; }
  .tooltip {
    position:absolute; background:#333; color:white; padding:10px;
    border-radius:6px; font-size:12px; max-width:300px; z-index:10;
  }
  .edit-field {
    width:100%; background:#555; color:white; border:none;
    margin:3px 0; font-size:12px;
  }
  .save-btn {
    margin-top:8px; padding:5px 10px; background:#6FA8DC;
    border:none; border-radius:4px; color:black; font-weight:bold;
    cursor:pointer; width:100%;
  }
</style>
</head>
<body>
<svg width="1300" height="900"></svg>
<div id="tooltip" class="tooltip" style="display:none;"></div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
d3.json("graph.json").then(function(root) {
  const svg = d3.select("svg"), width=+svg.attr("width"), height=+svg.attr("height");
  const tooltip=d3.select("#tooltip");
  const color=d3.scaleOrdinal().domain(["C","P","A"]).range(["#FFD966","#6FA8DC","#93C47D"]);

  let nodes=[],links=[];

  // === initial conceptual nodes ===
  nodes.push(root);
  if(root.children){
    root.children.filter(d=>d.id&&d.id.startsWith("C")).forEach(c=>{
      nodes.push(c);
      links.push({source:root.id,target:c.id,relation:"HAS_CONCEPT"});
    });
  }

  // === add concept interconnections ===
  function addConceptConnections(data){
    if(!data.children)return;
    data.children.filter(d=>d.id && d.id.startsWith("C")).forEach(c=>{
      // Add concept-to-concept relations from JSON
      if(c.connections){
        c.connections.forEach(conn=>{
          links.push({
            source: c.id,
            target: conn.to,
            relation: conn.relation
          });
        });
      }

      // Add procedural and assessment connections with proper relation names
      if(c.children){
        c.children.forEach(child=>{
          if(child.id.startsWith("P"))
            links.push({source: c.id, target: child.id, relation: "PROCEDURAL_FOR"});
          else if(child.id.startsWith("A"))
            links.push({source: c.id, target: child.id, relation: "ASSESSES"});

          // Add any nested procedural steps
          if(child.children){
            child.children.forEach(grand=>{
              links.push({source: child.id, target: grand.id, relation: "HAS_STEP"});
            });
          }
        });
      }

      // Recurse into deeper conceptual levels
      addConceptConnections(c);
    });
  }

  // === smoother physics ===
  const simulation=d3.forceSimulation(nodes)
    .force("link",d3.forceLink(links).id(d=>d.id).distance(180).strength(1))
    .force("charge",d3.forceManyBody().strength(-600))
    .force("center",d3.forceCenter(width/2,height/2))
    .force("collision",d3.forceCollide().radius(d=>d.id.startsWith("C")?45:30).strength(0.8))
    .velocityDecay(0.8)
    .alphaDecay(0.02);

  // === arrow marker ===
  svg.append("defs").append("marker")
    .attr("id","arrow").attr("viewBox","0 -5 10 10")
    .attr("refX",22).attr("refY",0)
    .attr("markerWidth",6).attr("markerHeight",6)
    .attr("orient","auto")
    .append("path").attr("d","M0,-5L10,0L0,5").attr("fill","#aaa");

  const linkGroup=svg.append("g").attr("class","links");
  const labelGroup=svg.append("g").attr("class","labels");
  const nodeGroup=svg.append("g").attr("class","nodes");
  let link=linkGroup.selectAll("line");
  let edgeLabel=labelGroup.selectAll(".edge-label");
  let node=nodeGroup.selectAll(".node");

  // === update ===
  function update(){
    // links
    link=link.data(links,d=>`${d.source.id||d.source}-${d.target.id||d.target}`);
    link.exit().remove();
    const linkEnter=link.enter().append("line").attr("class","link").style("opacity",0);
    link=linkEnter.merge(link);
    linkEnter.transition().duration(1200).ease(d3.easeCubicOut).style("opacity",1);

    // labels
    edgeLabel=edgeLabel.data(links,d=>`${d.source.id||d.source}-${d.target.id||d.target}`);
    edgeLabel.exit().remove();
    const labelEnter=edgeLabel.enter().append("text").attr("class","edge-label")
      .text(d=>d.relation||"").style("opacity",0);
    edgeLabel=labelEnter.merge(edgeLabel);
    labelEnter.transition().duration(1200).delay(600).ease(d3.easeCubicOut).style("opacity",1);

    // nodes
    node=node.data(nodes,d=>d.id);
    node.exit().remove();
    const nodeEnter=node.enter().append("g").attr("class","node")
      .call(d3.drag().on("start",dragstarted).on("drag",dragged).on("end",dragended));

    nodeEnter.append("circle")
      .attr("r",d=>d.id.startsWith("C")?25:d.id.startsWith("P")?15:10)
      .attr("fill",d=>color(d.id[0]))
      .style("opacity",0)
      .on("click",expandNode)
      .on("mouseover",showTooltip);

    nodeEnter.append("text").attr("x",8).attr("y",4)
      .text(d=>d.name||d.id).style("opacity",0);

    node=nodeEnter.merge(node);

    nodeEnter.select("circle").transition().duration(1500)
      .delay((d,i)=>i*150).ease(d3.easeCubicOut).style("opacity",1);
    nodeEnter.select("text").transition().duration(1500)
      .delay((d,i)=>i*150+400).ease(d3.easeCubicOut).style("opacity",1);

    simulation.nodes(nodes);
    simulation.force("link").links(links);
    simulation.alpha(0.3).restart();
  }

  // === expand node ===
  function expandNode(event,d){
    event.stopPropagation();
    if(!d.children || d.expanded) return;
    d.expanded = true;

    const newNodes = d.children.filter(child => !nodes.find(n => n.id === child.id));
    newNodes.forEach(child => { child.x = d.x; child.y = d.y; });
    nodes.push(...newNodes);

    // Use meaningful relationships instead of generic HAS_CHILD
    d.children.forEach(child => {
      let relType = "HAS_CHILD";
      if(child.id.startsWith("P")) relType = "PROCEDURAL_FOR";
      else if(child.id.startsWith("A")) relType = "ASSESSES";
      else if(child.id.startsWith("C")) relType = "HAS_CONCEPT";
      links.push({source: d.id, target: child.id, relation: relType});
    });

    update();
  }

  // === tooltip with save ===
  function showTooltip(event,d){
    let html=`<b>${d.name||d.id}</b><br>`;
    for(const [key,val] of Object.entries(d)){
      if(["id","name","children","x","y","vx","vy","fx","fy","index","expanded"].includes(key))continue;
      if(Array.isArray(val)&&val.length&&typeof val[0]==="object"){
        html+=`<div style='margin-top:5px'><b>${key}:</b><br>`;
        val.forEach((obj,i)=>{
          Object.entries(obj).forEach(([subkey,subval])=>{
            html+=`<input class='edit-field' data-key='${key}.${i}.${subkey}' value="${subval}"><br>`;
          });
        });
        html+=`</div>`;
      }else if(Array.isArray(val)){
        html+=`${key}: <input class='edit-field' data-key='${key}' value="${val.join(", ")}"><br>`;
      }else{
        html+=`${key}: <input class='edit-field' data-key='${key}' value="${val}"><br>`;
      }
    }
    html+=`<button class='save-btn'>Save Changes</button>`;
    tooltip.html(html)
      .style("left",(event.pageX+15)+"px")
      .style("top",(event.pageY-15)+"px")
      .style("display","block");

    tooltip.select(".save-btn").on("click",()=>{
      tooltip.selectAll(".edit-field").each(function(){
        const input=d3.select(this);
        const path=input.attr("data-key").split(".");
        let ref=d;
        for(let i=0;i<path.length-1;i++){
          if(Array.isArray(ref))ref=ref[parseInt(path[i])];
          else ref=ref[path[i]];
        }
        const lastKey=path[path.length-1];
        ref[lastKey]=input.property("value");
      });
      alert("Changes saved.");
    });

    // click outside closes it
    d3.select("body").on("click",function(e){
      if(!tooltip.node().contains(e.target))tooltip.style("display","none");
    },true);
  }

  simulation.on("tick",()=>{
    link.attr("x1",d=>d.source.x)
        .attr("y1",d=>d.source.y)
        .attr("x2",d=>d.target.x)
        .attr("y2",d=>d.target.y);
    edgeLabel.attr("x",d=>(d.source.x+d.target.x)/2)
             .attr("y",d=>(d.source.y+d.target.y)/2);
    node.attr("transform",d=>`translate(${d.x},${d.y})`);
  });

  function dragstarted(event){
    if(!event.active)simulation.alphaTarget(0.3).restart();
    event.subject.fx=event.subject.x; event.subject.fy=event.subject.y;
  }
  function dragged(event){event.subject.fx=event.x; event.subject.fy=event.y;}
  function dragended(event){
    if(!event.active)simulation.alphaTarget(0);
    event.subject.fx=null; event.subject.fy=null;
  }

  update();
});
</script>
</body>
</html>
